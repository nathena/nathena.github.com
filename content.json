{"pages":[{"title":"","permalink":"/README.html","text":"nathena.github.ionathena"},{"title":"about","permalink":"/about/index.html","text":"教育经历 厦大 联系方式 Location:Xiamen, Fujian, China github:nathena Email:nathena@qq.com"}],"posts":[{"title":"life_cycle","permalink":"/2017/02/15/php/life-cycle/","text":"开始和结束PHP_MINIT_FUNCTION(myextension)/ZEND_MINIT_FUNCTION 第一阶段 模块初始化阶段； 注册模块常量，类等初始化操作； CLI和CGI模式（单进程模式） 1PHP的生命周期在一次请求中完成。也就是说每次执行PHP脚本; 多进程模式： 123456789多进程模式可以将PHP内置到Web Server中，PHP可以编译成Apache下的prefork MPM模式和APXS模块，当Apache启动后，会fork很多子进程，每个子进程拥有自己独立的进程地址空间；在一个子进程中，PHP的生命周期是调用MINT启动后，执行多次请求（RINT/RSHUTDOWN)，在Apache关闭或进程结束后，才会调用MSHUTDOWN进行回收阶段。多进程模型中，每个子进程都是独立运行，没有代码和数据共享，因此一个子进程终止退出和重新生成，不会影响其他子进程的稳定 多线程模式： 1234Apache2的Worker MPM采用了多线程模型，在一个进程下创建多个线程，在同一个进程地址空间执行,一次M，多次R。 FastCGI模式： 12345678910Fastcgi是一种特殊的CGI模式，是一种常驻进程类型的CGI，运行后可以Fork多个进程，不用花费时间动态的Fork子进程，也不需要每次请求都调用MINT/MSHUTDOWN,PHP通过PHP-FPM来管理和调度FastCGI的进程,Nginx和PHP-FPM通过本地的TCP Socket和Unix Socket 进行通信。Php-fpm启动时进程A会调用MINIT方法，然后Fork出一个Fpm-Master进程B，(守护进程)，然后进程B启动多个Php-CGI子进程C，启动工作完成后，启动进程A就退出了（完成守护进程），子进程在每个请求过来时调用RINIT。 嵌入式： 12Embed SAPI是一种特殊的SAPI，允许在C/C++语言中调用PHP提供的函数;这种SAPI和CLI模式一样，按照Module Init =&gt; Request Init =&gt; Request =&gt; Request Shutdown =&gt; Module Shutdown的模式运行 PHP_RINIT_FUNCTION(myextension)/ZEND_RINIT_FUNCTION 第二阶段 request上下文初始化 PHP_RSHUTDOWN_FUNCTION(myextension)/ZEND_RSHUTDOWN_FUNCTION 第三阶段 request上下文结束 PHP_MSHUTDOWN_FUNCTION(myextension)/ZEND_MSHUTDOWN_FUNCTION 第四阶段 进程/线程结束"},{"title":"Hello World","permalink":"/2017/02/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"程序设计原则","permalink":"/2016/05/01/2016-04-01-programming_principles/","text":"程序设计法则 首先一些规则如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761.避免重复原则(DRY - Don’t repeat yourself) 编程的最基本原则是避免重复。在程序代码中总会有很多结构体，如循环、函数、类等等。一旦你重复某个语句或概念，就会很容易形成一个抽象体。 2.抽象原则(Abstraction Principle ) 与DRY原则相关。要记住，程序代码中每一个重要的功能，只能出现在源代码的一个位置。 3.简单原则(Keep It Simple and Stupid ) 简单是软件设计的目标，简单的代码占用时间少，漏洞少，并且易于修改。 4.避免创建你不要的代码 Avoid Creating a YAGNI (You aren’t going to need it) 除非你需要它，否则别创建新功能。 5.尽可能做可运行的最简单的事(Do the simplest thing that could possibly work) 尽可能做可运行的最简单的事。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢?”这将有助于在设计中保持简单的路径。 6.别让我思考(Don’t make me think ) 这是Steve Krug一本书的标题，同时也和编程有关。所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。 7.开闭原则(Open/Closed Principle) 你所编写的软件实体(类、模块、函数等)最好是开源的，这样别人可以拓展开发。不过，对于你的代码，得限定别人不得修改。换句话说，别人可以基于你的代码进行拓展编写，但却不能修改你的代码。 8.代码维护(Write Code for the Maintainer) 一个优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。用书中原话说“如果一个维护者不再继续维护你的代码，很可能他就有想杀了你的冲动。” 9.最小惊讶原则(Principle of least astonishment) 最小惊讶原则通常是在用户界面方面引用，但同样适用于编写的代码。代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。 10.单一责任原则(Single Responsibility Principle) 某个代码的功能，应该保证只有单一的明确的执行任务。 11.低耦合原则(Minimize Coupling) 代码的任何一个部分应该减少对其他区域代码的依赖关系。尽量不要使用共享参数。低耦合往往是完美结构系统和优秀设计的标志。 12.最大限度凝聚原则(Maximize Cohesion) 相似的功能代码应尽量放在一个部分。 13.隐藏实现细节(Hide Implementation Details) 隐藏实现细节原则，当其他功能部分发生变化时，能够尽可能降低对其他组件的影响。 14.迪米特法则又叫作最少知识原则(Law of Demeter) 该代码只和与其有直接关系的部分连接。(比如：该部分继承的类，包含的对象，参数传递的对象等)。 15.避免过早优化(Avoid Premature Optimization) 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。 “过早的优化是一切罪恶的根源”——Donald Knuth 16.代码重用原则(Code Reuse is Good) 重用代码能提高代码的可读性，缩短开发时间。 17.关注点分离(Separation of Concerns) 不同领域的功能，应该由不同的代码和最小重迭的模块组成。 18.拥抱改变(Embrace Change) 这是Kent Beck一本书的标题，同时也被认为是极限编程和敏捷方法的宗旨。 许多其他原则都是基于这个概念的，即你应该积极面对变化。事实上，一些较老的编程原则如最小化耦合原则都是为了使代码能够容易变化。无论你是否是个极限编程者，基于这个原则去编写代码会让你的工作变得更有意义。 其它 今日在公司谈起以上法则，忽然觉得其实任何事情都可以遵循类似的规则。特此注明。"},{"title":"ios手机浏览器事件冒泡","permalink":"/2016/04/08/2016-04-08-ios_event_bubbing/","text":"ios手机浏览器事件冒泡处理方式 On iOS there is no event bubbling without a cursor style.So in your CSS you need to add cursor: pointer; to the element."},{"title":"简说僵尸进程、守护进程与托管进程","permalink":"/2016/04/08/2016-04-08-zombie_daemon/","text":"托管进程 因为父进程异常结束了，然后被1号进程init收养 僵尸进程 一个进程使用fork创建子进程，如果子进程退出，父进程还在运行且父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程 守护进程 创建守护进程时有意把父进程结束，然后被1号进程init收养 12一个正常运行的子进程，如果此刻子进程退出，正在运行中的父进程没有及时调用wait或waitpid收回子进程的系统资源，该进程就是僵尸进程，如果系统收回了，就是正常退出，如果一个正常运行的子进程，父进程退出了但是子进程还在，该进程此刻是托管进程，被init收养，如果父进程是故意被杀掉，子进程做相应处理后就是守护进程 那么为了保证守护进程能正常创建，而不收启动进程的影响我们要这么干。父进程先fork出一个儿子进程，儿子进程再fork出孙子进程做为守护进程，然后儿子进程立刻退出，守护进程被init进程接管，这样无论父进程做什么事，无论怎么被阻塞，都与守护进程无关了。所以，fork两次的守护进程很安全，避免了僵尸进程出现的可能性。 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; void _deamon(void) { pid_t pid; if( ( pid = fork() )&gt;0 ) { printf(&quot;Parent is printing \\n&quot;); exit(1); } else if( pid &lt; 0 ) { printf(&quot;Parent fork failed %d\\n&quot;, pid ); exit(1); } printf(&quot;Frist Child is printing\\n&quot;); setsid(); if( ( pid = fork() )&gt;0 ) { printf(&quot;Second Parent is printing \\n&quot;); exit(1); } else if( pid &lt; 0 ) { printf(&quot;Second Parent fork failed %d\\n&quot;, pid ); exit(1); } printf(&quot;Second Child is printing\\n&quot;); } int main(int argc, char const *argv[]) { _deamon(); return 0; }"},{"title":"c标准库","permalink":"/2016/04/05/2016-04-05-c_standard_library/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&gt; #include &lt;assert.h&gt; 标准库的头文件中提供了一个宏称为断言可以用于验证程序的假设，如果这个假设是错误的，并打印诊断消息。&gt; #include &lt;ctype.h&gt; //字符处理提供的声明几个有用的函数测试和字符映射。所有的功能都接受int作为参数，其值必须是EOF或为unsigned char表示。所有函数返回的参数c非零（true），如果满足条件。否则返回0。#include &lt;errno.h&gt; //定义错误码#include &lt;float.h&gt; //浮点数处理#include &lt;limits.h&gt; //定义各种数据类型最值常量#include &lt;locale.h&gt; //定义本地化函数#include &lt;math.h&gt; //定义数学函数#include &lt;setjmp.h&gt; //文件输入／输出&gt; #include &lt;signal.h&gt; signal.h头文件中定义变量类型sig_atomic_t，两个函数调用和几个宏处理程序的执行过程中不同的信号报告。&gt; #include &lt;stdarg.h&gt; 不定参数#include &lt;stdio.h&gt; //定义输入／输出函数#include &lt;stdlib.h&gt; //定义杂项函数及内存分配函数#include &lt;string.h&gt; //字符串处理#include &lt;time.h&gt; //定义关于时间的函数&gt; #include &lt;stddef.h&gt; stddef.h 头文件定义了各种变量的类型和宏。许多这些定义也出现在其他头。1.Linux中一些头文件的作用：#include &lt;assert.h&gt; //ANSI C。提供断言，assert(表达式) #include &lt;glib.h&gt; //GCC。GTK，GNOME的基础库，提供很多有用的函数，如有数据结构操作函数 #include &lt;dirent.h&gt; //GCC。文件夹操作函数 #include &lt;ctype.h&gt; //ANSI C。字符测试函数。isdigit(),islower()等 #include &lt;errno.h&gt; //ANSI C。查看错误代码errno是调试程序的一个重要方法 #include &lt;getopt.h&gt; //处理命令行参数 2.linux常用头文件如下：//POSIX标准定义的头文件 #include &lt;dirent.h&gt; //目录项 #include &lt;fcntl.h&gt; //文件控制 #include &lt;fnmatch.h&gt; //文件名匹配类型 #include &lt;glob.h&gt; //路径名模式匹配类型 #include &lt;grp.h&gt; //组文件 #include &lt;netdb.h&gt; //网络数据库操作 #include &lt;pwd.h&gt; //口令文件 #include &lt;regex.h&gt; //正则表达式 #include &lt;tar.h&gt; //TAR归档值 #include &lt;termios.h&gt; //终端I/O #include &lt;unistd.h&gt; //符号常量 #include &lt;utime.h&gt; //文件时间 #include &lt;wordexp.h&gt; //字符扩展类型 //————————- #include &lt;arpa/inet.h&gt; //INTERNET定义 #include &lt;net/if.h&gt; //套接字本地接口 #include &lt;netinet/in.h&gt; //INTERNET地址族 #include &lt;netinet/tcp.h&gt; //传输控制协议定义 //————————- #include &lt;sys/mman.h&gt; //内存管理声明 #include &lt;sys/select.h&gt; //Select函数 #include &lt;sys/socket.h&gt; //套接字借口 #include &lt;sys/stat.h&gt; //文件状态 #include &lt;sys/times.h&gt; //进程时间 #include &lt;sys/types.h&gt; //基本系统数据类型 #include &lt;sys/un.h&gt; //UNIX域套接字定义 #include &lt;sys/utsname.h&gt; //系统名 #include &lt;sys/wait.h&gt; //进程控制 //—————————— //POSIX定义的XSI扩展头文件 #include &lt;cpio.h&gt; //cpio归档值 #include &lt;dlfcn.h&gt; //动态链接 #include &lt;fmtmsg.h&gt; //消息显示结构 #include &lt;ftw.h&gt; //文件树漫游 #include &lt;iconv.h&gt; //代码集转换使用程序 #include &lt;langinfo.h&gt; //语言信息常量 #include &lt;libgen.h&gt; //模式匹配函数定义 #include &lt;monetary.h&gt; //货币类型 #include &lt;ndbm.h&gt; //数据库操作 #include &lt;nl_types.h&gt; //消息类别 #include &lt;poll.h&gt; //轮询函数 #include &lt;search.h&gt; //搜索表 #include &lt;strings.h&gt; //字符串操作 #include &lt;syslog.h&gt; //系统出错日志记录 #include &lt;ucontext.h&gt; //用户上下文 #include &lt;ulimit.h&gt; //用户限制 #include &lt;utmpx.h&gt; //用户帐户数据库 //—————————– #include &lt;sys/ipc.h&gt; //IPC(命名管道) #include &lt;sys/msg.h&gt; //消息队列 #include &lt;sys/resource.h&gt; //资源操作 #include &lt;sys/sem.h&gt; //信号量 #include &lt;sys/shm.h&gt; //共享存储 #include &lt;sys/statvfs.h&gt; //文件系统信息 #include &lt;sys/time.h&gt; //时间类型 #include &lt;sys/timeb.h&gt; //附加的日期和时间定义 #include &lt;sys/uio.h&gt; //矢量I/O操作 //—————————— //POSIX定义的可选头文件 #include &lt;aio.h&gt; //异步I/O #include &lt;mqueue.h&gt; //消息队列 #include &lt;pthread.h&gt; //线程 #include &lt;sched.h&gt; //执行调度 #include &lt;semaphore.h&gt; //信号量 #include &lt;spawn.h&gt; //实时spawn接口 #include &lt;stropts.h&gt; //XSI STREAMS接口 #include &lt;trace.h&gt; //事件跟踪 3.C/C++头文件一览：//C #include &lt;assert.h&gt; //设定插入点 #include &lt;ctype.h&gt; //字符处理 #include &lt;errno.h&gt; //定义错误码 #include &lt;float.h&gt; //浮点数处理 #include &lt;iso646.h&gt; //对应各种运算符的宏 #include &lt;limits.h&gt; //定义各种数据类型最值的常量 #include &lt;locale.h&gt; //定义本地化C函数 #include &lt;math.h&gt; //定义数学函数 #include &lt;setjmp.h&gt; //异常处理支持 #include &lt;signal.h&gt; //信号机制支持 #include &lt;stdarg.h&gt; //不定参数列表支持 #include &lt;stddef.h&gt; //常用常量 #include &lt;stdio.h&gt; //定义输入／输出函数 #include &lt;stdlib.h&gt; //定义杂项函数及内存分配函数 #include &lt;string.h&gt; //字符串处理 #include &lt;time.h&gt; //定义关于时间的函数 #include &lt;wchar.h&gt; //宽字符处理及输入／输出 #include &lt;wctype.h&gt; //宽字符分类 //传统C++ #include &lt;fstream.h&gt; //改用&lt;fstream&gt; #include &lt;iomanip.h&gt; //改用&lt;iomainip&gt; #include &lt;iostream.h&gt; //改用&lt;iostream&gt; #include &lt;strstrea.h&gt; //该类不再支持，改用&lt;sstream&gt;中的stringstream //———————————————————————————————— //标准C++ #include &lt;algorithm&gt; //STL 通用算法 #include &lt;bitset&gt; //STL 位集容器 #include &lt;cctype&gt; //字符处理 #include &lt;cerrno&gt; //定义错误码 #include &lt;cfloat&gt; //浮点数处理 #include &lt;ciso646&gt; //对应各种运算符的宏 #include &lt;climits&gt; //定义各种数据类型最值的常量 #include &lt;clocale&gt; //定义本地化函数 #include &lt;cmath&gt; //定义数学函数 #include &lt;complex&gt; //复数类 #include &lt;csignal&gt; //信号机制支持 #include &lt;csetjmp&gt; //异常处理支持 #include &lt;cstdarg&gt; //不定参数列表支持 #include &lt;cstddef&gt; //常用常量 #include &lt;cstdio&gt; //定义输入／输出函数 #include &lt;cstdlib&gt; //定义杂项函数及内存分配函数 #include &lt;cstring&gt; //字符串处理 #include &lt;ctime&gt; //定义关于时间的函数 #include &lt;cwchar&gt; //宽字符处理及输入／输出 #include &lt;cwctype&gt; //宽字符分类 #include &lt;deque&gt; //STL 双端队列容器 #include &lt;exception&gt; //异常处理类 #include &lt;fstream&gt; //文件输入／输出 #include &lt;functional&gt; //STL 定义运算函数（代替运算符） #include &lt;limits&gt; //定义各种数据类型最值常量 #include &lt;list&gt; //STL 线性列表容器 #include &lt;locale&gt; //本地化特定信息 #include &lt;map&gt; //STL 映射容器 #include &lt;memory&gt; //STL通过分配器进行的内存分配 #include &lt;new&gt; //动态内存分配 #include &lt;numeric&gt; //STL常用的数字操作 #include &lt;iomanip&gt; //参数化输入／输出 #include &lt;ios&gt; //基本输入／输出支持 #include &lt;iosfwd&gt; //输入／输出系统使用的前置声明 #include &lt;iostream&gt; //数据流输入／输出 #include &lt;istream&gt; //基本输入流 #include &lt;iterator&gt; //STL迭代器 #include &lt;ostream&gt; //基本输出流 #include &lt;queue&gt; //STL 队列容器 #include &lt;set&gt; //STL 集合容器 #include &lt;sstream&gt; //基于字符串的流 #include &lt;stack&gt; //STL 堆栈容器 #include &lt;stdexcept&gt; //标准异常类 #include &lt;streambuf&gt; //底层输入／输出支持 #include &lt;string&gt; //字符串类 #include &lt;typeinfo&gt; //运行期间类型信息 #include &lt;utility&gt; //STL 通用模板类 #include &lt;valarray&gt; //对包含值的数组的操作 #include &lt;vector&gt; //STL 动态数组容器 //———————————————————————————————— //C99增加的部分 #include &lt;complex.h&gt; //复数处理 #include &lt;fenv.h&gt; //浮点环境 #include &lt;inttypes.h&gt; //整数格式转换 #include &lt;stdbool.h&gt; //布尔环境 #include &lt;stdint.h&gt; //整型环境 #include &lt;tgmath.h&gt; //通用类型数学宏"},{"title":"校招git工具培训命令纲要","permalink":"/2016/03/30/2016-03-30-git_merge&git_rebase/","text":"前言校招git工具培训命令纲要 git init git 仓库初始化 Initialized empty Git repository in /workspace/.git/ git checkout -b bracnh创建分支并切换到分支，git checkout master切换回主分钟 git add添加文件index git commit -m”提交描述” git commit -a -m”提交描述” ,将所有被修改或者已删除的且已经被git管理的文档提交倒仓库中 git merge branch git merge branch ,手动解决冲突 git add git commit git rebase branch git rebase branch ,手动解决冲突 git add git commit 123git merge/rebase non fast forward / fast forward冲突强制覆盖／不强制覆盖"},{"title":"javascript es4 es5 es6","permalink":"/2016/03/30/2016-03-30-javascsript-es4-es5-es6/","text":"javascript 规范简书1、es 262、es263 以上为常见的浏览器通用标准。 2、es4 此版本过于复杂，未被广大厂商接受 3、es5 1234567891011121314151617181920212223242526272829303132333435363738&gt; strict模式`` use strict `` &gt; Array 增加方法`` every、some、forEach、filter、indexOf、lastIndexOf、isArray、map、reduce、reduceRight ``&gt; Object 增加方法`` Object.getPrototypeOfObject.createObject.getOwnPropertyNamesObject.definePropertyObject.getOwnPropertyDescriptorObject.definePropertiesObject.keysObject.preventExtensions / Object.isExtensibleObject.seal / Object.isSealedObject.freeze / Object.isFrozen ``&gt; 其他增加方法`` Function.prototype.bind、String.prototype.trim、Date.now 等``es5主要为语言标准函数增强 es6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ECMAScript6在保证向下兼容的前提下，提供大量新特性1、块级作用域 关键字let, 常量const2、对象字面量的属性赋值简写 3、赋值解构4、函数参数 - 默认值、参数打包、数组展开5、箭头函数 Arrow functions6、字符串模板 Template strings7、Iterators（迭代器）+ for..of8、生成器 （Generators）9、Class 有constructor、extends、super，但本质上是语法糖，实际还是prototype10、Modules ES6的内置模块功能借鉴了CommonJS和AMD各自的优点，类似python的import ... from ...11、Map + Set + WeakMap + WeakSet 四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。12、Math + Number + String + Array + Object APIs`` Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&apos;*&apos;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &#123; origin: new Point(0,0) &#125;) ``13、Proxies 使用代理（Proxy）监听对象的操作，然后可以做一些相应事情``var target = &#123;&#125;;var handler = &#123;get: function (receiver, name) &#123;return `Hello, $&#123;name&#125;!`;&#125;&#125;;var p = new Proxy(target, handler);p.world === &apos;Hello, world!&apos;; 可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。``14、Symbols Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。`` var key = Symbol(&quot;key&quot;);var key2 = Symbol(&quot;key&quot;);key == key2 //false``15、Promises Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的 deferred 对象）。 总体来说es6有较多的特性，有些好有些一般。"},{"title":"为什么不使用tdd编程","permalink":"/2016/03/26/2016-03-26-why-do-not-use-tdd/","text":"不使用的理由 TDD鼓励保守：人们不愿意对应用程序做重大修改，因为他们知道许多测试会被破坏，他们必须重写。 “有时候，最好的设计是最难测试的那一种”。 TDD将注意力放在了细节上而不是整体。“使用TDD，你会陷入到程序不同部分的细节中去，很少回过头来看看全局。”很难为异常数据编写测试。 也许是对的 我相信，有关编写测试的事情不是说先写或是后写，而只是要写，有测试维护原则，并严格遵守你希望一个特定项目需要达到的代码覆盖量。先写有明显的好处，但那不是一项对每个人或对每个项目而言都有效的技术。根据我的经验，有时候会有一些时间限制，迫使你快速实现，然后只测试关键环节。我一直在创业公司及互联网公司工作，那是一个节奏非常快/注重市场的环境，为了发布并获得用于评估的数据，有时候你会欠下大量的技术债务（尤其是在创业公司的早期阶段）。"},{"title":"开篇文章","permalink":"/2016/03/25/2016-03-25-preface/","text":"花了几个小时搭建了这个博客，记录自己往后的工作立场。 书写过程使用了 yaml &amp; makrdown 2016年03月 记于厦门软件园"},{"title":"","permalink":"/2016/03/25/2016-03-25-test-markdown/","text":"h1测试h2h3h4 引用段落 代码段落 列表 列表 1、 列表1 2、 列表2 3、 列表3 内容 fads 发 1、发达的 2、fads 发 特 fad aa Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1"},{"title":"gcc参数","permalink":"/2016/03/25/2016-03-25-GCC_parameters/","text":"写在前面的话 从2009-03-06的百度空间翻出来，觉得现在还是可以使用，放到这里来。顺便吐槽下百度的产品：当初那么真心的使用百度hi，结果现在变成了这样。希望github.io给力。 正文 -c 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件 例子用法: gcc -c hello.c 他将生成.o的obj文件 -S 只激活预处理和编译，就是指把文件编译成为汇编代码。 例子用法 gcc -S hello.c 他将生成.s的汇编代码，你可以用文本编辑器察看 -E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面. 例子用法: gcc -E hello.c &gt;pianoapan.txt gcc -E hello.c | more 慢慢看吧,一个hello word 也要与处理成800行的代码 -o 制定目标名称,缺省的时候,gcc 编译出来的文件是a.out 例子用法 gcc -o hello.exe hello.c gcc -o hello.asm -S hello.c -pipe 使用管道代替编译中临时文件,在使用非gnu汇编工具的时候,可能有些问题 gcc -pipe -o hello.exe hello.c -ansi 关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏, -fno-asm 此选项实现ansi选项的功能的一部分，它禁止将asm,inline和typeof用作关键字。 -fno-strict-prototype 只对g++起作用,使用这个选项,g++将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有参数.而gcc无论是否使用这个参数,都将对没有带参数的函数,认为城没有显式说明的类型 -fthis-is-varialble 就是向传统c++看齐,可以使用this当一般变量使用. -fcond-mismatch 允许条件表达式的第二和第三参数类型不匹配,表达式的值将为void类型 -funsigned-char -fno-signed-char -fsigned-char -fno-unsigned-char 这四个参数是对char类型进行设置,决定将char类型设置成unsigned char(前两个参数)或者 signed char(后两个参数) -include file 包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,功能就相当于在代码中使用#include 例子用法: gcc hello.c -include /root/pianopan.h -imacros file 将file文件的宏,扩展到gcc/g++的输入文件,宏定义本身并不出现在输入文件中 -Dmacro 相当于C语言中的#define macro -Dmacro=defn 相当于C语言中的#define macro=defn -Umacro 相当于C语言中的#undef macro -undef 取消对任何非标准宏的定义 -Idir 在你是用#include”file”的时候,gcc/g++会先在当前目录查找你所制定的头文件,如果没有找到,他回到缺省的头文件目录找 -I- 就是取消前一个参数的功能,所以一般在-Idir之后使用 -idirafter dir 在-I的目录里面查找失败,转到这个目录里面查找. -iprefix prefix -iwithprefix dir 一般一起使用,当-I的目录查找失败,会到prefix+dir下查找 -nostdinc 使编译器不再系统缺省的头文件目录里面找头文件,一般和-I联合使用,明确限定头文件的位置 -nostdin C++ 规定不在g++指定的标准路经中搜索,但仍在其他路径中搜索,.此选项在创libg++库使用 -C 在预处理的时候,不删除注释信息,一般和-E使用 -M 生成文件关联的信息。包含目标文件所依赖的所有源代码。 -MM 和上面的那个一样，但是它将忽略由#include造成的依赖关系。 -MD 和-M相同，但是输出将导入到.d的文件里面 -MMD 和-MM相同，但是输出将导入到.d的文件里面 -Wa,option 此选项传递option给汇编程序;如果option中间有逗号,就将option分成多个选项,然后传递给会汇编程序 -Wl.option 此选项传递option给连接程序;如果option中间有逗号,就将option分成多个选项,然后传递给会连接程序. -llibrary 制定编译的时候使用的库例子用法gcc -lcurses hello.c -Ldir 制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个dir就是目录的名称。 -O0 -O1 -O2 -O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 -g 只是编译器，在编译的时候，产生调试信息。 -gstabs 此选项以stabs格式声称调试信息,但是不包括gdb调试信息. -gstabs+ 此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息. -ggdb 此选项将尽可能的生成gdb的可以使用的调试信息. -static 此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行. -share 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库. -traditional 试图让编译器支持传统的C语言特性"}]}